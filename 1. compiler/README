1. 编译过程

现在大多数程序员都是用IDE来完成整个编译过程。IDE提供了非常强大的功能，包含：错误检测、编译执行、断点调试等。然而对IDE的依赖会让我们忽略编译过程的底层细节，不了解程序是如何从源代码文件一步步被编译成可执行文件的过程及其原理，会让我们在写程序时充满了猜测；当遇到问题时，也很难能够快速定位和解决问题。

现在我们开始进入编程的魔法世界，了解程序是如何编译、链接以及执行的。在这个过程中，我们抛弃IDE，而是选择使用gcc，gcc是对cc1、as、ld等命令的一个封装。

首先，c/c++程序的编译过程一般包含如下四步：
- 预处理 (prepressing)
- 编译 (compilation)
- 汇编 (assembly)
- 链接 (linking)
最终，源代码文件被编译成可执行文件，能够被操作系统加载运行，去实现特定的功能。

1.1 预编译
命令： gcc -E hello.c -o hello.i
预编译过程主要处理源文件中以'#'开头的预编译指令：
- 将所有#define删除，并展开所有宏定义
- 处理所有的条件预编译指令，如#if，#ifdef，#elif，#else，#endif
- 处理#include指令，将被包含的文件插入到预编译指令的位置。#include会递归地将所有的引用文件导入
- 删除所有的注释信息
- 添加行号和文件名信息，以便调试器或当发生错误时告警使用
- 保留所有的#pragma指令，这种指令需要编译器来处理

1.2 编译
命令：gcc -S hello.i -o hello.s  或者  gcc -S hello.c -o hello.s  或者  cc1 hello.c -o hello.s
编译命令在预处理命令的基础上，对预处理文件进行更进一步的处理。主要包含：词法分析、语法分析、语义分析、中间代码生成，并最后在优化之后生成汇编代码。

1.3 汇编
命令：gcc -c hello.s -o hello.o  或者  gcc -c hello.c -o hello.o  或者  as hello.s -o hello.o
汇编将汇编代码翻译成机器可以执行的机器码。相较于编译，这一步非常简单，就是一个简单的翻译过程，几乎每一条汇编指令都对应一条机器指令。

1.4 链接
命令：gcc hello.o -o hello  或者  gcc hello.c -o hello
这一步也是编译器处理最复杂的一步。添加-v选项可以看到编译器的链接指令，这里的指令非常长，简化后的指令如下：
collect2 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o hello crt1.o crti.o crtbegin.o hello.o -lgcc -lgcc_s -lc crtend.o crtn.o
其中collect2是对链接器的一种封装。ld-linux-x86-64.so.2是真正的链接器。除了链接器和源文件之外，上面的指令中还出现了crt*系列的目标文件，这些文件都是系统提供的，所有这些目标文件合在一起最后被链接生成最终的可执行文件hello。

2. 编译器

2.1 纸带机
程序一般都是由多条指令构成，在远古时代，编程人员使用纸带机来编写程序，纸带机可以按照顺序执行指令。然而，程序中不可避免的会访问一些数据，或者执行跳转指令。那时，访问的数据的地址或指令跳转的地址都是由程序员来保证，如：
- 0：0001 0100
- 1：...
- 2：...
- 3：...
- 4：1000 0111
这里每个字节代码一条指令，其中高四位0001代表的是一条跳转指令，而低四位0100代表的则是跳转的局对地址，这里是4，当这条指令执行完毕之后，纸带机就跳转到绝对地址为4的指令处。这里有个问题：当程序经常发生变动时，程序中对应的绝对地址或相对地址都会发生变化，这里需要程序员不断的修正程序中对应的地址信息。可想而知，那是的程序员是多么的艰辛。

2.2 机器指令
随着计算机历史进程的推进，机器指令慢慢发展起来，程序员可以直接在计算机上编写机器指令，但是问题上面依然存在。

2.3 汇编语言
该问题直到汇编语言的出现才被解决。在汇编语言中，指令的地址可以使用符号来表示，如跳转到foo指令的地址如下：
- jmp foo
这里是一个非常重大的进步，程序员再也无需手动制定指令地址，而是由汇编器自动修正。程序员可以将所有的经历都投入到程序逻辑的设计开发中，这时程序的体量在不断的增长中。

2.4 高级语言c/c++
当程序体量增大到一定程序之后，汇编代码将会变得异常冗余、难看，开发效率也会显著降低。这时，聪明的程序员又开发出了一系列高级编程语言，比如c语言。当使用c语言编写程序时，整个程序会按照不同的功能进行划分，形成不同的功能模块，这里就是c源文件。

模块化编程带来的一个问题是：如何将这些不同功能的模块组合起来，形成最终单一的可执行文件。c源代码的组合主要分为两种：模块间变量的访问和模块间函数的访问。当访问其他模块的变量时，我们必须直到该变量的具体地址，同理函数访问也是如此。幸运的是，现在编译器会自动帮我我们完成这个过程：链接。

3. 静态链接
当我们将一个复杂的模块划分成一个个小模块，并对每个功能模块独立地编译，最后，我们还需要将这些模块组装起来，这个过程就是链接。链接的主要工作就是修正指令中对其他符号地址的引用，其过程主要包括：
- 地址和空间分配 (Addressing and storage allocation)
- 符号决议 (symbol resolution)，或者又称符号绑定。决议更倾向于静态链接，而绑定则更倾向于动态绑定。
- 重定位 (relocation)
链接的主要对象是目标文件(.o)，链接器将其与系统库进行链接。在链接之前，每个目标文件仅知道模块内部的符号地址，而对于模块外部符号的引用，编译器会在该符号处填充一个默认地址，一般都是0，而在链接时，链接器会自动修正这些地址值，使其指向符号真实的地址。

举个例子，假如某源文件中访问定义在另一个源文件中的变量var，并需要对其赋值：
- 源代码：var = 3;
- 汇编指令：mov 0x3, var;
- 机器指令：C705 00000000 03000000
上面可以看出，当编译器在编译源文件时，由于var不在该源文件中，编译器不能确定var的目标地址，因此将mov指令的目标地址设置成0。而链接器在链接所有目标文件时，var的目标地址就会确定下来，此时，链接器会将var的目标地址填充到上面00000000处。这个地址修正过程也被成为重定位。
