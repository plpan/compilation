### 符号定义
1. 在c/c++语言中，所有的变量名、函数名都是一个符号，在程序编译链接的过程中，编译器会对这些符号进行重定位：这个过程就是一个全局查表的过程，用其他模块中的符号定义来填充本模块的符号引用。
2. 在符号引用的过程中，主要存在两类问题：第一点，符号未定义，也即找遍了所有模块，都找不到该符号的定义；第二点，符号冲突，也即该符号在多个模块都被定义[符号冲突](https://github.com/pplonepiece/compilation/symbol/strong-conflict)。
3. 深入了解符号之后，发现其实符号本身也分为两类：第一类，强符号，包含函数名和初始化了的全局变量；第二类，弱符号，包含未初始化了的全局变量。
    - 通过gcc扩展`__attribute__((weak))`可以将强符号定义为弱符号[弱符号定义](https://github.com/pplonepiece/compilation/symbol/def)。
4. 符号定义必须遵守如下规范：
    - 如果强符号被定义多次，那么直接报错
    - 如果符号在一个模块中被定义为强符号，在其他模块中被定义为弱符号，那么就选择强符号作为该符号的定义，而且弱符号引用强符号
    - 如果符号在所有模块中都被定义为弱符号，则选择占内容最大弱符号定义的作为符号定义，并覆盖其他弱符号

### 符号引用
1. 针对两种类型符号，编译器在符号链接时处理也不同：针对强符号，如果在链接阶段找不到该符号定义，就报错，这被称为强引用；针对弱符号，如果在链接阶段找不到该符号的定义，那么该符号就未定义，编译器也不会报错，这被称为弱引用。
2. 对弱引用进行适当的延伸，就能实现非常有趣且有用的功能：动态加载。在模块内部声明一个弱引用（函数名），作为一个功能点，当被外部模块引用时，如果外部模块定义了这个符号的强引用，程序执行时，可以执行这个外部实现的功能；而如果外部模块没有定义这个符号的任何引用，就跳过这个功能点[利用弱引用实现功能扩展](http://github.com/pplonepiece/compilation/symbol/hook)。
